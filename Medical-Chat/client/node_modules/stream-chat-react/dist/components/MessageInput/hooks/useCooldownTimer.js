var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { useEffect, useMemo, useState } from 'react';
import { useChatContext } from '../../../context/ChatContext';
import { useChannelStateContext } from '../../../context/ChannelStateContext';
export var useCooldownTimer = function () {
    var _a;
    var latestMessageDatesByChannels = useChatContext('useCooldownTimer').latestMessageDatesByChannels;
    var _b = useChannelStateContext('useCooldownTimer'), channel = _b.channel, _c = _b.messages, messages = _c === void 0 ? [] : _c;
    var client = useChatContext('useCooldownTimer').client;
    var _d = useState(), cooldownRemaining = _d[0], setCooldownRemaining = _d[1];
    var _e = (channel.data ||
        {}), cooldownInterval = _e.cooldown, own_capabilities = _e.own_capabilities;
    var skipCooldown = !(own_capabilities === null || own_capabilities === void 0 ? void 0 : own_capabilities.includes('slow-mode'));
    var ownLatestMessageDate = useMemo(function () {
        var _a, _b;
        return (_a = latestMessageDatesByChannels[channel.cid]) !== null && _a !== void 0 ? _a : (_b = __spreadArray([], messages, true).sort(function (a, b) { var _a, _b; return ((_a = b.created_at) === null || _a === void 0 ? void 0 : _a.getTime()) - ((_b = a.created_at) === null || _b === void 0 ? void 0 : _b.getTime()); })
            .find(function (v) { var _a, _b; return ((_a = v.user) === null || _a === void 0 ? void 0 : _a.id) === ((_b = client.user) === null || _b === void 0 ? void 0 : _b.id); })) === null || _b === void 0 ? void 0 : _b.created_at;
    }, [messages, (_a = client.user) === null || _a === void 0 ? void 0 : _a.id, latestMessageDatesByChannels, channel.cid]);
    useEffect(function () {
        if (skipCooldown || !cooldownInterval || !ownLatestMessageDate)
            return;
        var remainingCooldown = Math.round(cooldownInterval - (new Date().getTime() - ownLatestMessageDate.getTime()) / 1000);
        if (remainingCooldown > 0)
            setCooldownRemaining(remainingCooldown);
    }, [cooldownInterval, ownLatestMessageDate, skipCooldown]);
    return {
        cooldownInterval: cooldownInterval !== null && cooldownInterval !== void 0 ? cooldownInterval : 0,
        cooldownRemaining: cooldownRemaining,
        setCooldownRemaining: setCooldownRemaining,
    };
};
